# 分区排序

## 问题概述
- 数据块是内存中的有序数组
- 分区是数据块的有序排列，分区内数据块不相交
- 需要对 X 个分区进行全局排序

## 思路
同时考虑最好情况和最差情况。

最好情况是，所有分区没有交集，分区之间可以直接排序。

最差情况是，不同分区的任意两个数据块之间都有交集，退化为归并排序。

#### 基本思路
整体思路是，如果分区或数据块不相交，可直接合并；否则，把相交的分区退化为数据块的合并，把相交的数据块退化为数组的合并。

数据块链表合并后，再重新等分为同样数量的分区；数值链表合并后，再重新等分为同样数量的数据块。否则随着归并的进行，相交越来越多。

先考虑两个分区链表合并的情况，令 plist1, plist2 为分区链表，每个链表中的分区有序。排序后输出到 plist3。
1. plist1 和 plist2 分别取出第一个分区 p1, p2 进行比较。
2. 如果分区之间无交集，可把较小者放入 plist3，然后从该分区所在链表继续取下一个分区。
3. 如果分区之间有交集，把 p1, p2 分别放入缓冲队列 q1 和 q2。
4. 同时从 plist1, plist2 取下一个分区，如果该分区与队列有交集，则继续放入缓冲队列 q1 和 q2。
5. 迭代上一步，直到遇到没有交集的区分，或队列取完。
6. 把缓冲队列 q1 和 q2 中的分区，退化为数据块链表，进行归并。归并过程同分区链表的归并。
7. 数据块链表归并为一个链表，把该链表等分为多个分区，以保证后续的归并过程，不会逐步退化为数据块的合并。
8. 把新分区输出到 plist3。返回第 1 步。

#### 多线程优化
1. 初始时，一个分区链表仅包含一个分区。
2. 两个分区链表的合并，看作一个任务，放到任务队列中。
3. 每个线程既是消费者，也是生产者。每次消费 2 个分区链表，生产 1 个分区链表。
4. 每次消费从队头取元素，生产时从队尾压元素，这样保证先消费较短的元素。
5. 当队列只剩 1 个元素，且没有正在进行的任务时，结束。

#### 复杂度
令分区数有 K 个，总共的数据有 N 条。

最优情况，排序的时间复杂度为 O(K * logK)，合并为数组的时间复杂度为 O(N)，空间复杂度为 O(N)。

平均时间复杂度为 O(N * logK)，空间复杂度为 O(N)。

## 代码结构
ComparableContainer - Block 和 Partition 的父类

Block - 数据块的定义

Partition - 分区的定义

MergeSortJob - 描述一个归并任务，包含归并的核心代码

MergeSortThreadPoolExecutor - 线程池 & 任务队列

MergeSortK - 算法入口

TestCase - 测试用例
